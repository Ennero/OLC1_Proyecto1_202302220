# Manual Técnico - Proyecto 1
## Objetivos
### Objetivo General
- Proporcionar una explicación detallada sobre la implementación del código, la lógica utilizada y las bases para el mantenimiento futuro del programa.
### Objetivos Específicos
- Presentar y explicar el funcionamiento del código que implementa la solución desarrollada.
- Detallar el proceso de diseño de las soluciones y la lógica detrás de cada una de ellas.

## Alcances del Sistema

Este manual tiene como finalidad facilitar la comprensión de cómo se implementaron las funcionalidades del programa y cómo estas interactúan entre sí para cumplir con el propósito del sistema.
En este se describe:
- La gramática utilizada por el compilador.
- Las herramientas empleadas pra el análisis léxico y sintáctico del compilador.
- El flujo de trabajo que permite generar los reportes y la salida que describe el desarrollo de la partida y el comportamiento de las estrategias.
Con esta información se espera garantizar un mantenimiento adecuado del software y una evolución eficiente en el futuro.

## Especificaciones técnicas
### Requisitos de Hardware
- Memoria RAM de 1GB
- Espacio libre en el disco duro de 2GB
- Procesador de 1GHz o superior
- Pantalla
- Teclado
- Mouse (opcional)
### Requisitos de Software 
- Sistema operativo compatible con JDK
- Editor de texto o IDE compatible que permita trabajar con java (se recomienda netBeans)
- Tener instalado JDK
## Lógica y descripción de la solución

### Main
Para la ejecución de todo el código dentro de este archivo se colocaron las funciones principales para el manejo de tablas en las cuales se guaradarían todo los tokesn y lo errores, así como las funciones que llamarían el análisis sintáctico y lexico.

#### Main
En esta función se inicializa toda la interfaz gráfica
```java
    public static void main(String[] args) throws Exception {
        //Inicio el programa con la interfaz gráfica
        System.out.println("Iniciando el programa");

        gui.setVisible(true);
        gui.setLocationRelativeTo(null);

    }
```
#### Variables globales
Estas se usaron para manejar de una forma más práctica todas las funciones del programa.
```java
    static public LinkedList<String[]> tokens = new LinkedList<>();
    static public LinkedList<String[]> errores = new LinkedList<>();
    public static String salidita = "";
    public static GUI gui = new GUI();

        public static int contador1 = 0;
        public static int contador2 = 0;
```

#### Función análisisLexico
Esta se encarga de realizar el análisis léxico para poder genrar la tabla de tokens, esta directamente crea arreglos y los coloca dentro de la tabla de tokens.

```
static public void analisisLexico(String input) throws IOException {
        Lexer lexer = new Lexer(new StringReader(input));
        Symbol token;
        contador2 = 0;
        while ((token = lexer.next_token()).sym != sym.EOF) {
            // Incrementa el contador

            // Si es un error, agregar al arreglo de errores
            if (sym.terminalNames[token.sym].equals("ERROR_LEXICO")) {
                // Crea un nuevo arreglo para el token
                contador1++;
                String[] arreglo = new String[5];
                arreglo[0] = Integer.toString(contador1);
                arreglo[1] = sym.terminalNames[token.sym];
                arreglo[2] = token.value.toString();
                arreglo[3] = Integer.toString(token.left);
                arreglo[4] = Integer.toString(token.right);

                errores.add(arreglo);
                //break;
            } else {
                contador2++;
                // Crea un nuevo arreglo para el token
                String[] arreglo = new String[5];
                arreglo[0] = Integer.toString(contador2);
                arreglo[1] = sym.terminalNames[token.sym];
                arreglo[2] = token.value.toString();
                arreglo[3] = Integer.toString(token.left);
                arreglo[4] = Integer.toString(token.right);

                // Si no es un error, agregar al arreglo de tokens
                tokens.add(arreglo);
            }
        }
    }
```

#### Función analisisSintactico
Esta función se utiliza para poder realizar el funcionamiento del programa y ejecutar la partida con todo lo que esto conlleva.
```java
    static public void analisisSintactico(String input) throws Exception {
        Lexer lexer = new Lexer(new StringReader(input));
        salidita = "";

        tokens.clear();
        errores.clear();
        Parser.erroresSintacticos.clear();

        analisisLexico(input);
        Parser parser = new Parser(lexer);

        try {
            parser.parse();
        } catch (Exception e) {
            System.err.println("Error durante el análisis sintáctico: " + e.getMessage());
        }

        // Si hay errores sintácticos, detener la ejecución
        if (!Parser.erroresSintacticos.isEmpty()) {
            errores.addAll(Parser.erroresSintacticos);
            throw new Exception("Errores sintácticos detectados. No se puede continuar con la ejecución.");
        }

        // Si no hay errores, continuar con la ejecución
        Entorno global = new Entorno("global");
        String SALIDA = "";
        for (Instruccion instruccion : parser.sentencias) {
            try {
                instruccion.jugar(global);
                for (String salida : utilidades.Salida.salidaInfo) {
                    SALIDA += salida + "\n";
                }
            } catch (Exception e) {
                gui.SintacError();
            }
        }
        System.out.println(SALIDA);
        salidita = SALIDA;
    }
```

#### Función analisito
Esta función, al igual que la anterior, realiza un análisis sintáctico, con la diferencia de que no inicia la partida, por lo que se utiliza unicamente para poder crear la tabla de errores, añadiendo los errores sintácticos.

### Interfaz gráfica
La interfaz gráfica se creó con Swing y contiene textArea y botones para interactuar con esta

#### Botones
El botón *jButton1ActionPerformed* se encarga de iniciar la ejecución del programa en el que se realiza un análisis sintáctico para verificar si es que se cumple con la sintaxis y lo muestra.

```java
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         

        String entrada = jTextArea2.getText();
        System.out.println(entrada);

        if (!errorLexico) {
            try {
                OLC1_Proyecto1_202302220.analisisSintactico(entrada);
                JOptionPane.showMessageDialog(this, "Análisis sintáctico completado");
                jTextArea3.setText(OLC1_Proyecto1_202302220.salidita);
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(this, "No se puede continuar con la ejecución debido a errores sintácticos o léxicos.", "Error", JOptionPane.ERROR_MESSAGE);
                Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            JOptionPane.showMessageDialog(this, "No se puede continuar debido a errores léxicos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }   
```
El botón *jButton5ActionPerformed* Se encarga de realizar el análisis léxico para que se muestre a posterior la tabla de tokens dentro de la interfaz gráfica.

```java
    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:

        //Esta parte es para limpiar la lista de tokenes y la tablita
        model.setRowCount(0);
        while (!OLC1_Proyecto1_202302220.tokens.isEmpty()) {
            OLC1_Proyecto1_202302220.tokens.remove();
        }
        while (!OLC1_Proyecto1_202302220.errores.isEmpty()) {
            OLC1_Proyecto1_202302220.errores.remove();
        }
        jTable1.setModel(model);
        errorLexico = false;

        try {
            //Comienzo leyendo la entrada
            String entrada = jTextArea2.getText();
            System.out.println(entrada);

            //PARTE DEL ANÁLSIS LÉXICO -------------------------------------------------------------------------------------------
            OLC1_Proyecto1_202302220.analisisLexico(entrada);
            // Verificar si hay tokens

            if (!OLC1_Proyecto1_202302220.errores.isEmpty()) { //Si es que hay errores
                JOptionPane.showMessageDialog(this, "Hay errores léxicos");
                errorLexico = true;
            } else { //Si es que no hay errores
                for (String[] token : OLC1_Proyecto1_202302220.tokens) {
                    model.addRow(token);
                }
            }
            System.out.println("Análisis lexico completado");

        } catch (IOException ex) {
            Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }  

```
El botón *jButton6ActionPerformed* se encarga de, igualmente que el botón previamente descrito, realizar el análisis pero para poder mostrar los errores que hay y mostrarlos en la tabla, volvéndose esta en esta ocasión tabla de errores.
```java
    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        model.setRowCount(0); // Limpiar tabla

        tokens.clear();
        errores.clear();

        jTable1.setModel(model);
        errorLexico = false;
        OLC1_Proyecto1_202302220.contador1=0;

        try {
            // Leer entrada del área de texto
            String entrada = jTextArea2.getText();
            System.out.println(entrada);

            // Ejecutar análisis (léxico + sintáctico)
            OLC1_Proyecto1_202302220.analisito(entrada);

            // Verificar si hay errores (léxicos o sintácticos)
            if (!OLC1_Proyecto1_202302220.errores.isEmpty()) {
                for (String[] error : OLC1_Proyecto1_202302220.errores) {
                    model.addRow(error);
                    errorLexico = true;
                }
            } else {
                JOptionPane.showMessageDialog(this, "No hay errores léxicos ni sintácticos para colocar en la tabla");
            }
        } catch (Exception ex) {
            Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }      
```
Todo esto se logra manejar gracias a variables globales dentro de la clase que son las siguientes:

```java
    static public String[] columnas = {"No.", "Tipo:", "Lexema:", "Linea:", "Columna"};
    static public DefaultTableModel model = new DefaultTableModel(columnas, 0);
    static boolean errorLexico = false;
    String nombreArchivo = "";
    boolean guardado = false;
    File archivoSeleccionado;

```
#### Bibliotecas
Las bibliotecas que se utilizaron para la creación de la interfaz gráfica son las siguientes:
```java
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import static olc1_proyecto1_202302220.OLC1_Proyecto1_202302220.errores;
import static olc1_proyecto1_202302220.OLC1_Proyecto1_202302220.tokens;
```
### Análisis Léxico
Para conseguir el análisis léxico se utilizó la herramienta *jflex*, la cual permite realizarlo de forma sencilla dentro de java y se puede unir con cup, la cual se utilizó también para el análisis sintáctico.

#### Importaciones
```java
package olc1_proyecto1_202302220.analizador;
import java_cup.runtime.Symbol;
```

#### Configuración de jflex
```java
%class Lexer
%public
%unicode
%cup
%line
%column
%char
```
Esta configuración deliminta el inicio de estas, especifica el nombre de la clase que se va a generar, hará que la clase sea pública, habilita el soporte para caracteres Unicode, indica que será compatible con CUP y hará un seguimiento de la línea, columan y posición de los caracteres.
#### Expresiones Regulares
```java
//PARA IGNORAR
WS = [ \t\r\n]+

//NUMEROS
ENTERO = [0-9]+
FLOTANTE = {ENTERO}\.{ENTERO}

// Comentarios y espacios en blanco -------
COMENTARIOS = "//"([^\r\n]*)?
COMENTARIOS_MULTILINEA = [/][*][^*]*[*]+([^/*][^*]*[*]+)*[/]

//IDENTIFICADORES
ID = [A-Za-z_][A-Za-z_0-9]*

```

#### Reglas de acción 
En estas se asocia cada expresión regular con una acción que se ejecutará cuando se encuentre coincidencia, creancon un objeto *Symbol* que representa los tokens y los devuelve al analizador sintáctico.

```java
//REGLAS DE ACCIÓN----------------------------------------------------------------------------------------------------
%%

{WS}     { /* Ignorar espacios en blanco */ }

// PALABRAS RESERVADAS-----

//BLOQUES PRINCIPALES
"strategy"  { return new Symbol(sym.STRATEGY, yyline + 1, (int) yycolumn + 1, yytext()); }
"initial"  { return new Symbol(sym.INITIAL, yyline + 1, (int) yycolumn + 1, yytext()); }
"match"  { return new Symbol(sym.MATCH, yyline + 1, (int) yycolumn + 1, yytext()); }
"main"  { return new Symbol(sym.MAIN, yyline + 1, (int) yycolumn + 1, yytext()); }

//ACCIONES
"C" { return new Symbol(sym.C, yyline + 1, (int) yycolumn + 1, yytext()); }
"D" { return new Symbol(sym.D, yyline + 1, (int) yycolumn + 1, yytext()); }

//RELACIONADO A STRATEGY
"rules"  { return new Symbol(sym.RULES, yyline + 1, (int) yycolumn + 1, yytext()); }
"if"  { return new Symbol(sym.IF, yyline + 1, (int) yycolumn + 1, yytext()); }
"then"  { return new Symbol(sym.THEN, yyline + 1, (int) yycolumn + 1, yytext()); }
"else"  { return new Symbol(sym.ELSE, yyline + 1, (int) yycolumn + 1, yytext()); }

//funciones especiales dentro de strategy
"get_move" { return new Symbol(sym.GET_MOVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"last_move" { return new Symbol(sym.LAST_MOVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"get_moves_count" { return new Symbol(sym.GET_MOVES_COUNT, yyline + 1, (int) yycolumn + 1, yytext()); }
"get_last_n_moves" { return new Symbol(sym.GET_LAST_N_MOVES, yyline + 1, (int) yycolumn + 1, yytext()); }

//RELACIONADO A MATCH
"round_number"  { return new Symbol(sym.ROUND_NUMBER, yyline + 1, (int) yycolumn + 1, yytext()); }
"total_rounds"  { return new Symbol(sym.TOTAL_ROUNDS, yyline + 1, (int) yycolumn + 1, yytext()); }
"players" { return new Symbol(sym.PLAYERS, yyline + 1, (int) yycolumn + 1, yytext()); }
"strategies"  { return new Symbol(sym.STRATEGIES, yyline + 1, (int) yycolumn + 1, yytext()); }
"rounds" { return new Symbol(sym.ROUNDS, yyline + 1, (int) yycolumn + 1, yytext()); }
"scoring"  { return new Symbol(sym.SCORING, yyline + 1, (int) yycolumn + 1, yytext()); }


//RELACIONADO A MAIN
"run"  { return new Symbol(sym.RUN, yyline + 1, (int) yycolumn + 1, yytext()); }
"with"  { return new Symbol(sym.WITH, yyline + 1, (int) yycolumn + 1, yytext()); }
"seed"  { return new Symbol(sym.SEED, yyline + 1, (int) yycolumn + 1, yytext()); }

//PUNTAJES
"mutual cooperation" { return new Symbol(sym.MUTUAL_COOPERATION, yyline + 1, (int) yycolumn + 1, yytext()); }
"mutual defection" { return new Symbol(sym.MUTUAL_DEFECTION, yyline + 1, (int) yycolumn + 1, yytext()); }
"betrayal reward" { return new Symbol(sym.BETRAYAL_REWARD, yyline + 1, (int) yycolumn + 1, yytext()); }
"betrayal punishment"  { return new Symbol(sym.BETRAYAL_PUNISHMENT, yyline + 1, (int) yycolumn + 1, yytext()); }

"random" { return new Symbol(sym.RANDOM, yyline + 1, (int) yycolumn + 1, yytext()); }

//LISTA DE HISTORIAL
"opponent_history" { return new Symbol(sym.OPPONENT_HISTORY, yyline + 1, (int) yycolumn + 1, yytext()); }
"self_history" { return new Symbol(sym.SELF_HISTORY, yyline + 1, (int) yycolumn + 1, yytext()); }

//BOOLEANOS
"true" { return new Symbol(sym.TRUE, yyline + 1, (int) yycolumn + 1, yytext()); }
"false" { return new Symbol(sym.FALSE, yyline + 1, (int) yycolumn + 1, yytext()); }

//VALORES
{ENTERO} { return new Symbol(sym.ENTERO, yyline + 1, (int) yycolumn + 1, (yytext())); }   //parsear despues
{FLOTANTE} { return new Symbol(sym.FLOTANTE, yyline + 1, (int) yycolumn + 1, (yytext())); }  //parsear despues
{ID} { return new Symbol(sym.ID, yyline + 1, yycolumn + 1, yytext()); }


// OPERADORES--------
// Lógicas
"&&"  { return new Symbol(sym.AND, yyline + 1, (int) yycolumn + 1, yytext()); }
"||"  { return new Symbol(sym.OR, yyline + 1, (int) yycolumn + 1, yytext()); }
"!"  { return new Symbol(sym.NOT, yyline + 1, (int) yycolumn + 1, yytext()); }

// Comparadores
"=="  { return new Symbol(sym.IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }
"!="  { return new Symbol(sym.NO_IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }
"<"  { return new Symbol(sym.MENOR, yyline + 1, (int) yycolumn + 1, yytext()); }
">"  { return new Symbol(sym.MAYOR, yyline + 1, (int) yycolumn + 1, yytext()); }
"<="  { return new Symbol(sym.MENOR_IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }
">="  { return new Symbol(sym.MAYOR_IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }

// OTROS----------
"[" { return new Symbol(sym.ABRE_CORCHETE, yyline + 1, (int) yycolumn + 1, yytext()); }
"]" { return new Symbol(sym.CIERRA_CORCHETE, yyline + 1, (int) yycolumn + 1, yytext()); }
"{" { return new Symbol(sym.ABRE_LLAVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"}" { return new Symbol(sym.CIERRA_LLAVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"(" { return new Symbol(sym.ABRE_PARENTESIS, yyline + 1, (int) yycolumn + 1, yytext()); }
")" { return new Symbol(sym.CIERRA_PARENTESIS, yyline + 1, (int) yycolumn + 1, yytext()); }
"," { return new Symbol(sym.COMA, yyline + 1, (int) yycolumn + 1, yytext()); }
":" { return new Symbol(sym.DOS_PUNTOS, yyline + 1, (int) yycolumn + 1, yytext()); }

{COMENTARIOS} { /* Ignorar comentario de línea */ }
{COMENTARIOS_MULTILINEA} { /* Ignorar comentario de varias líneas */ }

// SINO ENTONCES ESTO XD DEBE DE LANZAR UN EXCEPCION O ALGO MAS+++++6+2+5+5+52+252+652+6246+
.    { return new Symbol(sym.ERROR_LEXICO, yyline + 1, yycolumn + 1, yytext()); }
//{ throw new Error("Error léxico en fila " + (yyline + 1) + " columna " + (yycolumn + 1)); }
```
### Análisis Sintáctico
El análisis sintáctico permite que se pueda corroborar que los tokens se encuentre en el orden en el cual deberían de estar. Para esto, como se mencionó previamente, se utilizó cup, con el cual, además de permitir que se pueda hacer esta revisión, permite que se guarden los valores para su posterior utilización.

#### Importaciones
Aquí se importa todo lo necesario para que funciones correctamente el archivo del analizador sintáctico
```java
/* 1. Package e importaciones */
package olc1_proyecto1_202302220.analizador;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import olc1_proyecto1_202302220.*;
import utilidades.*;
import expresion.*;
import abstractas.*;
import instruccion.*;
import objetos.*;
import java.util.ArrayList;
import java.util.Arrays;
import random.DeterministicRandomGenerator;
import random.RandomGenerator;
import funciones.*;
```

#### Codigo ejecutable del parser
Aquí se coloca todo el código de java que se usará de forma global en el programa
```java
parser code
{:
    public ArrayList<Instruccion> sentencias;
    public static LinkedList<String[]> erroresSintacticos = new LinkedList<>();

    @Override
    public void syntax_error(Symbol s) {
        String[] error = new String[5];
        OLC1_Proyecto1_202302220.contador1++;
        error[0] = Integer.toString(OLC1_Proyecto1_202302220.contador1+1); // Número de error
        error[1] = "ERROR_SINTACTICO";
        error[2] = (s.value != null) ? s.value.toString() : "null";
        error[3] = Integer.toString(s.left);
        error[4] = Integer.toString(s.right);

        // Agregar a la lista de errores sintácticos
        erroresSintacticos.add(error);
    }
:}
```
#### Declaración de terminales
En esta sección del analizador sintáctico se declaran los símbolos terminales que fueron generados por el analizador léxico.
```java
//Para el error (yo en esta carrera)
terminal ERROR_LEXICO;
//Estructurales
terminal String STRATEGY, MATCH, MAIN;
//Acciones
terminal String C, D;
//Secciones
terminal String INITIAL, RULES;
//Flujo
terminal String IF, THEN, ELSE;
//Funciones especiales dentro de strategy
terminal String GET_MOVE, LAST_MOVE, GET_LAST_N_MOVES, GET_MOVES_COUNT;
//Funciones relacionada a match
terminal String ROUND_NUMBER, PLAYERS, STRATEGIES, ROUNDS, TOTAL_ROUNDS;
//Historiales
terminal String OPPONENT_HISTORY, SELF_HISTORY;
//Booleanos
terminal String TRUE, FALSE;
//Puntajes
terminal String MUTUAL_COOPERATION, MUTUAL_DEFECTION, BETRAYAL_REWARD, BETRAYAL_PUNISHMENT;
//Configuración
terminal String SCORING, RUN, WITH, SEED;
//Logicas
terminal String AND, OR, NOT;
//Comparadores
terminal String IGUAL, NO_IGUAL, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;
//Otros
terminal String ABRE_CORCHETE, CIERRA_CORCHETE, ABRE_LLAVE, CIERRA_LLAVE, ABRE_PARENTESIS, CIERRA_PARENTESIS, COMA, DOS_PUNTOS;
//Tipos
terminal String ENTERO, FLOTANTE;
//Identificador
terminal String ID;
//Otros
terminal String RANDOM;
```
#### Declaración de no terminales
Se declaran los símbolos que representan las contrucciones gramaticales del lenguaje.
```java
//Init y bloques
non terminal ini;
non terminal ArrayList<Instruccion> iniciar;
non terminal Instruccion instruccion;
//Lo del bloque strategy
non terminal CrearEstrategia bloque_Strategy;
non terminal InstruccionEstrategia strategy_Cuerpo;
non terminal Expresion regla_Inicial;
non terminal ArrayList<Regla> reglas;
non terminal ArrayList<Regla> lista_Reglas;
//Lo que va en el bloque match
non terminal Instruccion bloque_Match;
non terminal InstruccionPartida match_Cuerpo;
non terminal Jugadores jugadores;
non terminal Expresion rondas;
non terminal Puntos puntuaciones;
non terminal Puntos puntos;
non terminal Expresion puntuacion;
//Lo que va en el bloque main
non terminal Instruccion bloque_Main;
non terminal main_Cuerpo;
non terminal match_Lista;
//PARTES COMPLEMENTARIAS DEL CODIGO :)
non terminal Expresion expresion;
non terminal Expresion comparacion;
non terminal logica;
non terminal funcion;
non terminal lista;
non terminal elemento;
non terminal Expresion decision;
```

#### Declaración de precedencia
Aquí se declara la precedencia para dar algún tipo de sentido semántico a la gramática
```java
precedence left OR, AND, IGUAL, NO_IGUAL, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;
precedence nonassoc NOT;
```

#### Producciones
Aquí se define la gramática del lenguaje que se utilizó
```java
start with ini;
ini ::= iniciar:iniciar {: sentencias = iniciar; :};

iniciar ::= iniciar:l instruccion:i     {: RESULT = l; RESULT.add(i); :}
| instruccion:i                 {: RESULT = new ArrayList<>(Arrays.asList(i));  :}
;
instruccion ::= bloque_Strategy:e   {: RESULT = e; :}
| bloque_Match:e                    {: RESULT = e; :}
| bloque_Main:e                     {: RESULT = e; :}
;
//-------------------------------------
//BLOQUE DE STRATEGIAS
bloque_Strategy ::= STRATEGY ID:n ABRE_LLAVE strategy_Cuerpo:inst CIERRA_LLAVE {: RESULT = new CrearEstrategia(n, inst); :} ;
strategy_Cuerpo ::= regla_Inicial:i reglas:r  {: RESULT= new InstruccionEstrategia(i,r); :};
regla_Inicial ::= INITIAL DOS_PUNTOS decision:d {: RESULT= d; :};
reglas ::= RULES DOS_PUNTOS ABRE_CORCHETE lista_Reglas:l CIERRA_CORCHETE {:RESULT=l; :};
lista_Reglas::= IF expresion:c THEN expresion:a COMA lista_Reglas:l     {: RESULT = l; RESULT.add(new Regla(c, a)); :} 
| IF expresion:c THEN expresion:a                                      {: RESULT = new ArrayList<Regla>(Arrays.asList(new Regla(c, a))); :}
| ELSE expresion:a                                                     {: RESULT = new ArrayList<Regla>(Arrays.asList(new Regla(null, a))); :}
;
//-------------------------------------
//BLOQUE DE PARTIDAS
bloque_Match ::= MATCH ID:n ABRE_LLAVE match_Cuerpo:inst CIERRA_LLAVE {: RESULT = new CrearPartida(n, inst); :} ;
match_Cuerpo ::= jugadores:j rondas:r puntuaciones:p {: RESULT = new InstruccionPartida(j, r, p); :};
jugadores ::= PLAYERS STRATEGIES DOS_PUNTOS ABRE_CORCHETE ID:j1 COMA
                ID:j2 CIERRA_CORCHETE   {: RESULT = new Jugadores(j1, j2); :} ;
rondas ::= ROUNDS DOS_PUNTOS expresion:exp {: RESULT = exp; :} ;
puntuaciones ::= SCORING DOS_PUNTOS ABRE_LLAVE puntos:p CIERRA_LLAVE {: RESULT = p; :} ;
puntos ::= puntuacion:c COMA puntuacion:d COMA puntuacion:tr COMA puntuacion:ta  {: RESULT = new Puntos(c, d, tr, ta); :} ;
puntuacion ::= MUTUAL_COOPERATION DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
| MUTUAL_DEFECTION DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
| BETRAYAL_REWARD DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
| BETRAYAL_PUNISHMENT DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
;
//-------------------------------------
//BLOQUE DE INICIO
bloque_Main ::= MAIN ABRE_LLAVE main_Cuerpo:p CIERRA_LLAVE {: RESULT = new Inicio(p); :} ;
main_Cuerpo ::= RUN ABRE_CORCHETE ID:id CIERRA_CORCHETE WITH 
        ABRE_LLAVE SEED DOS_PUNTOS expresion CIERRA_LLAVE {: RESULT = id; :} ;
//Aqui el auxiliar colocó que no se "reproducía la lista" ****
//Así que lo probaré como si sí y luego veo si es viable tal y como lo ando haciendo ****
//match_Lista ::= match_Lista COMA ID 
//| ID:id {:  RESULT = :}
//;
//Aqui el auxiliar colocó que no se "reproducía la lista" ****
//Así que lo probaré como si sí y luego veo si es viable tal y como lo ando haciendo ****
//-------------------------------------
//PARTES COMPLEMENTARIAS DEL CODIGO :)
decision ::= C:d {: RESULT = new Primitiva(d, TipoTipo.DECISION); :}
| D:d {: RESULT = new Primitiva(d, TipoTipo.DECISION); :}
;
expresion ::= comparacion:r {: RESULT =r; :}
| logica
| decision:d {: RESULT = d; :}
| funcion
| lista
| RANDOM:p {: RESULT = new RandomNumber(); :}
| OPPONENT_HISTORY 
| SELF_HISTORY 
| ROUND_NUMBER:r {: RESULT =new RondaActual(); :}
| TOTAL_ROUNDS:R {: RESULT =new TotalRondas(); :}
| TRUE:p         {: RESULT = new Primitiva(p,TipoTipo.BOOLEANO); :}
| FALSE:p        {: RESULT = new Primitiva(p,TipoTipo.BOOLEANO); :}
| ENTERO:p       {: RESULT = new Primitiva(p,TipoTipo.ENTERO); :}
| FLOTANTE:p     {: RESULT = new Primitiva(p,TipoTipo.FLOTANTE); :}
;
comparacion ::= expresion:exp1 IGUAL:op expresion:exp2                   {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 NO_IGUAL:op expresion:exp2                              {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MENOR:op expresion:exp2                                 {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MAYOR:op expresion:exp2                                 {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MENOR_IGUAL:op expresion:exp2                           {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MAYOR_IGUAL:op expresion:exp2                           {: RESULT = new Comparacion(exp1,op,exp2); :}
;
logica ::= expresion AND expresion
| expresion OR expresion
| NOT expresion
;
funcion ::= GET_MOVE:funcion ABRE_PARENTESIS expresion:exp1 COMA expresion:exp2 CIERRA_PARENTESIS {: RESULT = new Funcion(funcion, exp1, exp2); :}
| LAST_MOVE:funcion ABRE_PARENTESIS expresion:exp1 CIERRA_PARENTESIS                              {: RESULT = new Funcion(funcion, exp1, null); :}
| GET_MOVES_COUNT:funcion ABRE_PARENTESIS expresion:exp1 COMA expresion:exp2 CIERRA_PARENTESIS    {: RESULT = new Funcion(funcion, exp1, exp2); :}
| GET_LAST_N_MOVES:funcion ABRE_PARENTESIS expresion:exp1 COMA expresion:exp2 CIERRA_PARENTESIS   {: RESULT = new Funcion(funcion, exp1, exp2); :}
;
lista ::= ABRE_CORCHETE elemento CIERRA_CORCHETE ;
elemento ::= elemento COMA expresion
| expresion
;
```


### Ejecución del programa
Para la ejecución del programa, como se mencionó previamente, se crearon muchas clases que se fueron guardando durante el análisis sintáctico con cup para que, cuando se tenga que iniciar el programa, se pueda adentrar en estas y ejecutar todo tal y como debería.

```java




```