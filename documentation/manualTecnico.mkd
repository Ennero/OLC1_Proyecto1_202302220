# Manual Técnico - Proyecto 1
## Objetivos
### Objetivo General
- Proporcionar una explicación detallada sobre la implementación del código, la lógica utilizada y las bases para el mantenimiento futuro del programa.
### Objetivos Específicos
- Presentar y explicar el funcionamiento del código que implementa la solución desarrollada.
- Detallar el proceso de diseño de las soluciones y la lógica detrás de cada una de ellas.

## Alcances del Sistema

Este manual tiene como finalidad facilitar la comprensión de cómo se implementaron las funcionalidades del programa y cómo estas interactúan entre sí para cumplir con el propósito del sistema.
En este se describe:
- La gramática utilizada por el compilador.
- Las herramientas empleadas pra el análisis léxico y sintáctico del compilador.
- El flujo de trabajo que permite generar los reportes y la salida que describe el desarrollo de la partida y el comportamiento de las estrategias.
Con esta información se espera garantizar un mantenimiento adecuado del software y una evolución eficiente en el futuro.

## Especificaciones técnicas
### Requisitos de Hardware
- Memoria RAM de 1GB
- Espacio libre en el disco duro de 2GB
- Procesador de 1GHz o superior
- Pantalla
- Teclado
- Mouse (opcional)
### Requisitos de Software 
- Sistema operativo compatible con JDK
- Editor de texto o IDE compatible que permita trabajar con java (se recomienda netBeans)
- Tener instalado JDK
## Lógica y descripción de la solución

### Main
Para la ejecución de todo el código dentro de este archivo se colocaron las funciones principales para el manejo de tablas en las cuales se guaradarían todo los tokesn y lo errores, así como las funciones que llamarían el análisis sintáctico y lexico.

#### Main
En esta función se inicializa toda la interfaz gráfica
```java
    public static void main(String[] args) throws Exception {
        //Inicio el programa con la interfaz gráfica
        System.out.println("Iniciando el programa");

        gui.setVisible(true);
        gui.setLocationRelativeTo(null);

    }
```
#### Variables globales
Estas se usaron para manejar de una forma más práctica todas las funciones del programa.
```java
    static public LinkedList<String[]> tokens = new LinkedList<>();
    static public LinkedList<String[]> errores = new LinkedList<>();
    public static String salidita = "";
    public static GUI gui = new GUI();

        public static int contador1 = 0;
        public static int contador2 = 0;
```

#### Función análisisLexico
Esta se encarga de realizar el análisis léxico para poder genrar la tabla de tokens, esta directamente crea arreglos y los coloca dentro de la tabla de tokens.

```
static public void analisisLexico(String input) throws IOException {
        Lexer lexer = new Lexer(new StringReader(input));
        Symbol token;
        contador2 = 0;
        while ((token = lexer.next_token()).sym != sym.EOF) {
            // Incrementa el contador

            // Si es un error, agregar al arreglo de errores
            if (sym.terminalNames[token.sym].equals("ERROR_LEXICO")) {
                // Crea un nuevo arreglo para el token
                contador1++;
                String[] arreglo = new String[5];
                arreglo[0] = Integer.toString(contador1);
                arreglo[1] = sym.terminalNames[token.sym];
                arreglo[2] = token.value.toString();
                arreglo[3] = Integer.toString(token.left);
                arreglo[4] = Integer.toString(token.right);

                errores.add(arreglo);
                //break;
            } else {
                contador2++;
                // Crea un nuevo arreglo para el token
                String[] arreglo = new String[5];
                arreglo[0] = Integer.toString(contador2);
                arreglo[1] = sym.terminalNames[token.sym];
                arreglo[2] = token.value.toString();
                arreglo[3] = Integer.toString(token.left);
                arreglo[4] = Integer.toString(token.right);

                // Si no es un error, agregar al arreglo de tokens
                tokens.add(arreglo);
            }
        }
    }
```

#### Función analisisSintactico
Esta función se utiliza para poder realizar el funcionamiento del programa y ejecutar la partida con todo lo que esto conlleva.
```java
    static public void analisisSintactico(String input) throws Exception {
        Lexer lexer = new Lexer(new StringReader(input));
        salidita = "";

        tokens.clear();
        errores.clear();
        Parser.erroresSintacticos.clear();

        analisisLexico(input);
        Parser parser = new Parser(lexer);

        try {
            parser.parse();
        } catch (Exception e) {
            System.err.println("Error durante el análisis sintáctico: " + e.getMessage());
        }

        // Si hay errores sintácticos, detener la ejecución
        if (!Parser.erroresSintacticos.isEmpty()) {
            errores.addAll(Parser.erroresSintacticos);
            throw new Exception("Errores sintácticos detectados. No se puede continuar con la ejecución.");
        }

        // Si no hay errores, continuar con la ejecución
        Entorno global = new Entorno("global");
        String SALIDA = "";
        for (Instruccion instruccion : parser.sentencias) {
            try {
                instruccion.jugar(global);
                for (String salida : utilidades.Salida.salidaInfo) {
                    SALIDA += salida + "\n";
                }
            } catch (Exception e) {
                gui.SintacError();
            }
        }
        System.out.println(SALIDA);
        salidita = SALIDA;
    }
```

#### Función analisito
Esta función, al igual que la anterior, realiza un análisis sintáctico, con la diferencia de que no inicia la partida, por lo que se utiliza unicamente para poder crear la tabla de errores, añadiendo los errores sintácticos.

### Interfaz gráfica
La interfaz gráfica se creó con Swing y contiene textArea y botones para interactuar con esta

#### Botones
El botón *jButton1ActionPerformed* se encarga de iniciar la ejecución del programa en el que se realiza un análisis sintáctico para verificar si es que se cumple con la sintaxis y lo muestra.

```java
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         

        String entrada = jTextArea2.getText();
        System.out.println(entrada);

        if (!errorLexico) {
            try {
                OLC1_Proyecto1_202302220.analisisSintactico(entrada);
                JOptionPane.showMessageDialog(this, "Análisis sintáctico completado");
                jTextArea3.setText(OLC1_Proyecto1_202302220.salidita);
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(this, "No se puede continuar con la ejecución debido a errores sintácticos o léxicos.", "Error", JOptionPane.ERROR_MESSAGE);
                Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            JOptionPane.showMessageDialog(this, "No se puede continuar debido a errores léxicos.", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }   
```
El botón *jButton5ActionPerformed* Se encarga de realizar el análisis léxico para que se muestre a posterior la tabla de tokens dentro de la interfaz gráfica.

```java
    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:

        //Esta parte es para limpiar la lista de tokenes y la tablita
        model.setRowCount(0);
        while (!OLC1_Proyecto1_202302220.tokens.isEmpty()) {
            OLC1_Proyecto1_202302220.tokens.remove();
        }
        while (!OLC1_Proyecto1_202302220.errores.isEmpty()) {
            OLC1_Proyecto1_202302220.errores.remove();
        }
        jTable1.setModel(model);
        errorLexico = false;

        try {
            //Comienzo leyendo la entrada
            String entrada = jTextArea2.getText();
            System.out.println(entrada);

            //PARTE DEL ANÁLSIS LÉXICO -------------------------------------------------------------------------------------------
            OLC1_Proyecto1_202302220.analisisLexico(entrada);
            // Verificar si hay tokens

            if (!OLC1_Proyecto1_202302220.errores.isEmpty()) { //Si es que hay errores
                JOptionPane.showMessageDialog(this, "Hay errores léxicos");
                errorLexico = true;
            } else { //Si es que no hay errores
                for (String[] token : OLC1_Proyecto1_202302220.tokens) {
                    model.addRow(token);
                }
            }
            System.out.println("Análisis lexico completado");

        } catch (IOException ex) {
            Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }  

```
El botón *jButton6ActionPerformed* se encarga de, igualmente que el botón previamente descrito, realizar el análisis pero para poder mostrar los errores que hay y mostrarlos en la tabla, volvéndose esta en esta ocasión tabla de errores.
```java
    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        model.setRowCount(0); // Limpiar tabla

        tokens.clear();
        errores.clear();

        jTable1.setModel(model);
        errorLexico = false;
        OLC1_Proyecto1_202302220.contador1=0;

        try {
            // Leer entrada del área de texto
            String entrada = jTextArea2.getText();
            System.out.println(entrada);

            // Ejecutar análisis (léxico + sintáctico)
            OLC1_Proyecto1_202302220.analisito(entrada);

            // Verificar si hay errores (léxicos o sintácticos)
            if (!OLC1_Proyecto1_202302220.errores.isEmpty()) {
                for (String[] error : OLC1_Proyecto1_202302220.errores) {
                    model.addRow(error);
                    errorLexico = true;
                }
            } else {
                JOptionPane.showMessageDialog(this, "No hay errores léxicos ni sintácticos para colocar en la tabla");
            }
        } catch (Exception ex) {
            Logger.getLogger(GUI.class.getName()).log(Level.SEVERE, null, ex);
        }
    }      
```
Todo esto se logra manejar gracias a variables globales dentro de la clase que son las siguientes:

```java
    static public String[] columnas = {"No.", "Tipo:", "Lexema:", "Linea:", "Columna"};
    static public DefaultTableModel model = new DefaultTableModel(columnas, 0);
    static boolean errorLexico = false;
    String nombreArchivo = "";
    boolean guardado = false;
    File archivoSeleccionado;

```
#### Bibliotecas
Las bibliotecas que se utilizaron para la creación de la interfaz gráfica son las siguientes:
```java
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import static olc1_proyecto1_202302220.OLC1_Proyecto1_202302220.errores;
import static olc1_proyecto1_202302220.OLC1_Proyecto1_202302220.tokens;
```
### Análisis Léxico
Para conseguir el análisis léxico se utilizó la herramienta *jflex*, la cual permite realizarlo de forma sencilla dentro de java y se puede unir con cup, la cual se utilizó también para el análisis sintáctico.

#### Importaciones
```java
package olc1_proyecto1_202302220.analizador;
import java_cup.runtime.Symbol;
```

#### Configuración de jflex
```java
%class Lexer
%public
%unicode
%cup
%line
%column
%char
```
Esta configuración deliminta el inicio de estas, especifica el nombre de la clase que se va a generar, hará que la clase sea pública, habilita el soporte para caracteres Unicode, indica que será compatible con CUP y hará un seguimiento de la línea, columan y posición de los caracteres.
#### Expresiones Regulares
```java
//PARA IGNORAR
WS = [ \t\r\n]+

//NUMEROS
ENTERO = [0-9]+
FLOTANTE = {ENTERO}\.{ENTERO}

// Comentarios y espacios en blanco -------
COMENTARIOS = "//"([^\r\n]*)?
COMENTARIOS_MULTILINEA = [/][*][^*]*[*]+([^/*][^*]*[*]+)*[/]

//IDENTIFICADORES
ID = [A-Za-z_][A-Za-z_0-9]*

```

#### Reglas de acción 
En estas se asocia cada expresión regular con una acción que se ejecutará cuando se encuentre coincidencia, creancon un objeto *Symbol* que representa los tokens y los devuelve al analizador sintáctico.

```java
//REGLAS DE ACCIÓN----------------------------------------------------------------------------------------------------
%%

{WS}     { /* Ignorar espacios en blanco */ }

// PALABRAS RESERVADAS-----

//BLOQUES PRINCIPALES
"strategy"  { return new Symbol(sym.STRATEGY, yyline + 1, (int) yycolumn + 1, yytext()); }
"initial"  { return new Symbol(sym.INITIAL, yyline + 1, (int) yycolumn + 1, yytext()); }
"match"  { return new Symbol(sym.MATCH, yyline + 1, (int) yycolumn + 1, yytext()); }
"main"  { return new Symbol(sym.MAIN, yyline + 1, (int) yycolumn + 1, yytext()); }

//ACCIONES
"C" { return new Symbol(sym.C, yyline + 1, (int) yycolumn + 1, yytext()); }
"D" { return new Symbol(sym.D, yyline + 1, (int) yycolumn + 1, yytext()); }

//RELACIONADO A STRATEGY
"rules"  { return new Symbol(sym.RULES, yyline + 1, (int) yycolumn + 1, yytext()); }
"if"  { return new Symbol(sym.IF, yyline + 1, (int) yycolumn + 1, yytext()); }
"then"  { return new Symbol(sym.THEN, yyline + 1, (int) yycolumn + 1, yytext()); }
"else"  { return new Symbol(sym.ELSE, yyline + 1, (int) yycolumn + 1, yytext()); }

//funciones especiales dentro de strategy
"get_move" { return new Symbol(sym.GET_MOVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"last_move" { return new Symbol(sym.LAST_MOVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"get_moves_count" { return new Symbol(sym.GET_MOVES_COUNT, yyline + 1, (int) yycolumn + 1, yytext()); }
"get_last_n_moves" { return new Symbol(sym.GET_LAST_N_MOVES, yyline + 1, (int) yycolumn + 1, yytext()); }

//RELACIONADO A MATCH
"round_number"  { return new Symbol(sym.ROUND_NUMBER, yyline + 1, (int) yycolumn + 1, yytext()); }
"total_rounds"  { return new Symbol(sym.TOTAL_ROUNDS, yyline + 1, (int) yycolumn + 1, yytext()); }
"players" { return new Symbol(sym.PLAYERS, yyline + 1, (int) yycolumn + 1, yytext()); }
"strategies"  { return new Symbol(sym.STRATEGIES, yyline + 1, (int) yycolumn + 1, yytext()); }
"rounds" { return new Symbol(sym.ROUNDS, yyline + 1, (int) yycolumn + 1, yytext()); }
"scoring"  { return new Symbol(sym.SCORING, yyline + 1, (int) yycolumn + 1, yytext()); }


//RELACIONADO A MAIN
"run"  { return new Symbol(sym.RUN, yyline + 1, (int) yycolumn + 1, yytext()); }
"with"  { return new Symbol(sym.WITH, yyline + 1, (int) yycolumn + 1, yytext()); }
"seed"  { return new Symbol(sym.SEED, yyline + 1, (int) yycolumn + 1, yytext()); }

//PUNTAJES
"mutual cooperation" { return new Symbol(sym.MUTUAL_COOPERATION, yyline + 1, (int) yycolumn + 1, yytext()); }
"mutual defection" { return new Symbol(sym.MUTUAL_DEFECTION, yyline + 1, (int) yycolumn + 1, yytext()); }
"betrayal reward" { return new Symbol(sym.BETRAYAL_REWARD, yyline + 1, (int) yycolumn + 1, yytext()); }
"betrayal punishment"  { return new Symbol(sym.BETRAYAL_PUNISHMENT, yyline + 1, (int) yycolumn + 1, yytext()); }

"random" { return new Symbol(sym.RANDOM, yyline + 1, (int) yycolumn + 1, yytext()); }

//LISTA DE HISTORIAL
"opponent_history" { return new Symbol(sym.OPPONENT_HISTORY, yyline + 1, (int) yycolumn + 1, yytext()); }
"self_history" { return new Symbol(sym.SELF_HISTORY, yyline + 1, (int) yycolumn + 1, yytext()); }

//BOOLEANOS
"true" { return new Symbol(sym.TRUE, yyline + 1, (int) yycolumn + 1, yytext()); }
"false" { return new Symbol(sym.FALSE, yyline + 1, (int) yycolumn + 1, yytext()); }

//VALORES
{ENTERO} { return new Symbol(sym.ENTERO, yyline + 1, (int) yycolumn + 1, (yytext())); }   //parsear despues
{FLOTANTE} { return new Symbol(sym.FLOTANTE, yyline + 1, (int) yycolumn + 1, (yytext())); }  //parsear despues
{ID} { return new Symbol(sym.ID, yyline + 1, yycolumn + 1, yytext()); }


// OPERADORES--------
// Lógicas
"&&"  { return new Symbol(sym.AND, yyline + 1, (int) yycolumn + 1, yytext()); }
"||"  { return new Symbol(sym.OR, yyline + 1, (int) yycolumn + 1, yytext()); }
"!"  { return new Symbol(sym.NOT, yyline + 1, (int) yycolumn + 1, yytext()); }

// Comparadores
"=="  { return new Symbol(sym.IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }
"!="  { return new Symbol(sym.NO_IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }
"<"  { return new Symbol(sym.MENOR, yyline + 1, (int) yycolumn + 1, yytext()); }
">"  { return new Symbol(sym.MAYOR, yyline + 1, (int) yycolumn + 1, yytext()); }
"<="  { return new Symbol(sym.MENOR_IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }
">="  { return new Symbol(sym.MAYOR_IGUAL, yyline + 1, (int) yycolumn + 1, yytext()); }

// OTROS----------
"[" { return new Symbol(sym.ABRE_CORCHETE, yyline + 1, (int) yycolumn + 1, yytext()); }
"]" { return new Symbol(sym.CIERRA_CORCHETE, yyline + 1, (int) yycolumn + 1, yytext()); }
"{" { return new Symbol(sym.ABRE_LLAVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"}" { return new Symbol(sym.CIERRA_LLAVE, yyline + 1, (int) yycolumn + 1, yytext()); }
"(" { return new Symbol(sym.ABRE_PARENTESIS, yyline + 1, (int) yycolumn + 1, yytext()); }
")" { return new Symbol(sym.CIERRA_PARENTESIS, yyline + 1, (int) yycolumn + 1, yytext()); }
"," { return new Symbol(sym.COMA, yyline + 1, (int) yycolumn + 1, yytext()); }
":" { return new Symbol(sym.DOS_PUNTOS, yyline + 1, (int) yycolumn + 1, yytext()); }

{COMENTARIOS} { /* Ignorar comentario de línea */ }
{COMENTARIOS_MULTILINEA} { /* Ignorar comentario de varias líneas */ }

// SINO ENTONCES ESTO XD DEBE DE LANZAR UN EXCEPCION O ALGO MAS+++++6+2+5+5+52+252+652+6246+
.    { return new Symbol(sym.ERROR_LEXICO, yyline + 1, yycolumn + 1, yytext()); }
//{ throw new Error("Error léxico en fila " + (yyline + 1) + " columna " + (yycolumn + 1)); }
```
### Análisis Sintáctico
El análisis sintáctico permite que se pueda corroborar que los tokens se encuentre en el orden en el cual deberían de estar. Para esto, como se mencionó previamente, se utilizó cup, con el cual, además de permitir que se pueda hacer esta revisión, permite que se guarden los valores para su posterior utilización.

#### Importaciones
Aquí se importa todo lo necesario para que funciones correctamente el archivo del analizador sintáctico
```java
/* 1. Package e importaciones */
package olc1_proyecto1_202302220.analizador;
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import olc1_proyecto1_202302220.*;
import utilidades.*;
import expresion.*;
import abstractas.*;
import instruccion.*;
import objetos.*;
import java.util.ArrayList;
import java.util.Arrays;
import random.DeterministicRandomGenerator;
import random.RandomGenerator;
import funciones.*;
```

#### Codigo ejecutable del parser
Aquí se coloca todo el código de java que se usará de forma global en el programa
```java
parser code
{:
    public ArrayList<Instruccion> sentencias;
    public static LinkedList<String[]> erroresSintacticos = new LinkedList<>();

    @Override
    public void syntax_error(Symbol s) {
        String[] error = new String[5];
        OLC1_Proyecto1_202302220.contador1++;
        error[0] = Integer.toString(OLC1_Proyecto1_202302220.contador1+1); // Número de error
        error[1] = "ERROR_SINTACTICO";
        error[2] = (s.value != null) ? s.value.toString() : "null";
        error[3] = Integer.toString(s.left);
        error[4] = Integer.toString(s.right);

        // Agregar a la lista de errores sintácticos
        erroresSintacticos.add(error);
    }
:}
```
#### Declaración de terminales
En esta sección del analizador sintáctico se declaran los símbolos terminales que fueron generados por el analizador léxico.
```java
//Para el error (yo en esta carrera)
terminal ERROR_LEXICO;
//Estructurales
terminal String STRATEGY, MATCH, MAIN;
//Acciones
terminal String C, D;
//Secciones
terminal String INITIAL, RULES;
//Flujo
terminal String IF, THEN, ELSE;
//Funciones especiales dentro de strategy
terminal String GET_MOVE, LAST_MOVE, GET_LAST_N_MOVES, GET_MOVES_COUNT;
//Funciones relacionada a match
terminal String ROUND_NUMBER, PLAYERS, STRATEGIES, ROUNDS, TOTAL_ROUNDS;
//Historiales
terminal String OPPONENT_HISTORY, SELF_HISTORY;
//Booleanos
terminal String TRUE, FALSE;
//Puntajes
terminal String MUTUAL_COOPERATION, MUTUAL_DEFECTION, BETRAYAL_REWARD, BETRAYAL_PUNISHMENT;
//Configuración
terminal String SCORING, RUN, WITH, SEED;
//Logicas
terminal String AND, OR, NOT;
//Comparadores
terminal String IGUAL, NO_IGUAL, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;
//Otros
terminal String ABRE_CORCHETE, CIERRA_CORCHETE, ABRE_LLAVE, CIERRA_LLAVE, ABRE_PARENTESIS, CIERRA_PARENTESIS, COMA, DOS_PUNTOS;
//Tipos
terminal String ENTERO, FLOTANTE;
//Identificador
terminal String ID;
//Otros
terminal String RANDOM;
```
#### Declaración de no terminales
Se declaran los símbolos que representan las contrucciones gramaticales del lenguaje.
```java
//Init y bloques
non terminal ini;
non terminal ArrayList<Instruccion> iniciar;
non terminal Instruccion instruccion;
//Lo del bloque strategy
non terminal CrearEstrategia bloque_Strategy;
non terminal InstruccionEstrategia strategy_Cuerpo;
non terminal Expresion regla_Inicial;
non terminal ArrayList<Regla> reglas;
non terminal ArrayList<Regla> lista_Reglas;
//Lo que va en el bloque match
non terminal Instruccion bloque_Match;
non terminal InstruccionPartida match_Cuerpo;
non terminal Jugadores jugadores;
non terminal Expresion rondas;
non terminal Puntos puntuaciones;
non terminal Puntos puntos;
non terminal Expresion puntuacion;
//Lo que va en el bloque main
non terminal Instruccion bloque_Main;
non terminal main_Cuerpo;
non terminal match_Lista;
//PARTES COMPLEMENTARIAS DEL CODIGO :)
non terminal Expresion expresion;
non terminal Expresion comparacion;
non terminal logica;
non terminal funcion;
non terminal lista;
non terminal elemento;
non terminal Expresion decision;
```

#### Declaración de precedencia
Aquí se declara la precedencia para dar algún tipo de sentido semántico a la gramática
```java
precedence left OR, AND, IGUAL, NO_IGUAL, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;
precedence nonassoc NOT;
```

#### Producciones
Aquí se define la gramática del lenguaje que se utilizó
```java
start with ini;
ini ::= iniciar:iniciar {: sentencias = iniciar; :};

iniciar ::= iniciar:l instruccion:i     {: RESULT = l; RESULT.add(i); :}
| instruccion:i                 {: RESULT = new ArrayList<>(Arrays.asList(i));  :}
;
instruccion ::= bloque_Strategy:e   {: RESULT = e; :}
| bloque_Match:e                    {: RESULT = e; :}
| bloque_Main:e                     {: RESULT = e; :}
;
//-------------------------------------
//BLOQUE DE STRATEGIAS
bloque_Strategy ::= STRATEGY ID:n ABRE_LLAVE strategy_Cuerpo:inst CIERRA_LLAVE {: RESULT = new CrearEstrategia(n, inst); :} ;
strategy_Cuerpo ::= regla_Inicial:i reglas:r  {: RESULT= new InstruccionEstrategia(i,r); :};
regla_Inicial ::= INITIAL DOS_PUNTOS decision:d {: RESULT= d; :};
reglas ::= RULES DOS_PUNTOS ABRE_CORCHETE lista_Reglas:l CIERRA_CORCHETE {:RESULT=l; :};
lista_Reglas::= IF expresion:c THEN expresion:a COMA lista_Reglas:l     {: RESULT = l; RESULT.add(new Regla(c, a)); :} 
| IF expresion:c THEN expresion:a                                      {: RESULT = new ArrayList<Regla>(Arrays.asList(new Regla(c, a))); :}
| ELSE expresion:a                                                     {: RESULT = new ArrayList<Regla>(Arrays.asList(new Regla(null, a))); :}
;
//-------------------------------------
//BLOQUE DE PARTIDAS
bloque_Match ::= MATCH ID:n ABRE_LLAVE match_Cuerpo:inst CIERRA_LLAVE {: RESULT = new CrearPartida(n, inst); :} ;
match_Cuerpo ::= jugadores:j rondas:r puntuaciones:p {: RESULT = new InstruccionPartida(j, r, p); :};
jugadores ::= PLAYERS STRATEGIES DOS_PUNTOS ABRE_CORCHETE ID:j1 COMA
                ID:j2 CIERRA_CORCHETE   {: RESULT = new Jugadores(j1, j2); :} ;
rondas ::= ROUNDS DOS_PUNTOS expresion:exp {: RESULT = exp; :} ;
puntuaciones ::= SCORING DOS_PUNTOS ABRE_LLAVE puntos:p CIERRA_LLAVE {: RESULT = p; :} ;
puntos ::= puntuacion:c COMA puntuacion:d COMA puntuacion:tr COMA puntuacion:ta  {: RESULT = new Puntos(c, d, tr, ta); :} ;
puntuacion ::= MUTUAL_COOPERATION DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
| MUTUAL_DEFECTION DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
| BETRAYAL_REWARD DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
| BETRAYAL_PUNISHMENT DOS_PUNTOS expresion:exp {: RESULT =  exp; :}
;
//-------------------------------------
//BLOQUE DE INICIO
bloque_Main ::= MAIN ABRE_LLAVE main_Cuerpo:p CIERRA_LLAVE {: RESULT = new Inicio(p); :} ;
main_Cuerpo ::= RUN ABRE_CORCHETE ID:id CIERRA_CORCHETE WITH 
        ABRE_LLAVE SEED DOS_PUNTOS expresion CIERRA_LLAVE {: RESULT = id; :} ;
//Aqui el auxiliar colocó que no se "reproducía la lista" ****
//Así que lo probaré como si sí y luego veo si es viable tal y como lo ando haciendo ****
//match_Lista ::= match_Lista COMA ID 
//| ID:id {:  RESULT = :}
//;
//Aqui el auxiliar colocó que no se "reproducía la lista" ****
//Así que lo probaré como si sí y luego veo si es viable tal y como lo ando haciendo ****
//-------------------------------------
//PARTES COMPLEMENTARIAS DEL CODIGO :)
decision ::= C:d {: RESULT = new Primitiva(d, TipoTipo.DECISION); :}
| D:d {: RESULT = new Primitiva(d, TipoTipo.DECISION); :}
;
expresion ::= comparacion:r {: RESULT =r; :}
| logica
| decision:d {: RESULT = d; :}
| funcion
| lista
| RANDOM:p {: RESULT = new RandomNumber(); :}
| OPPONENT_HISTORY 
| SELF_HISTORY 
| ROUND_NUMBER:r {: RESULT =new RondaActual(); :}
| TOTAL_ROUNDS:R {: RESULT =new TotalRondas(); :}
| TRUE:p         {: RESULT = new Primitiva(p,TipoTipo.BOOLEANO); :}
| FALSE:p        {: RESULT = new Primitiva(p,TipoTipo.BOOLEANO); :}
| ENTERO:p       {: RESULT = new Primitiva(p,TipoTipo.ENTERO); :}
| FLOTANTE:p     {: RESULT = new Primitiva(p,TipoTipo.FLOTANTE); :}
;
comparacion ::= expresion:exp1 IGUAL:op expresion:exp2                   {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 NO_IGUAL:op expresion:exp2                              {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MENOR:op expresion:exp2                                 {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MAYOR:op expresion:exp2                                 {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MENOR_IGUAL:op expresion:exp2                           {: RESULT = new Comparacion(exp1,op,exp2); :}
| expresion:exp1 MAYOR_IGUAL:op expresion:exp2                           {: RESULT = new Comparacion(exp1,op,exp2); :}
;
logica ::= expresion AND expresion
| expresion OR expresion
| NOT expresion
;
funcion ::= GET_MOVE:funcion ABRE_PARENTESIS expresion:exp1 COMA expresion:exp2 CIERRA_PARENTESIS {: RESULT = new Funcion(funcion, exp1, exp2); :}
| LAST_MOVE:funcion ABRE_PARENTESIS expresion:exp1 CIERRA_PARENTESIS                              {: RESULT = new Funcion(funcion, exp1, null); :}
| GET_MOVES_COUNT:funcion ABRE_PARENTESIS expresion:exp1 COMA expresion:exp2 CIERRA_PARENTESIS    {: RESULT = new Funcion(funcion, exp1, exp2); :}
| GET_LAST_N_MOVES:funcion ABRE_PARENTESIS expresion:exp1 COMA expresion:exp2 CIERRA_PARENTESIS   {: RESULT = new Funcion(funcion, exp1, exp2); :}
;
lista ::= ABRE_CORCHETE elemento CIERRA_CORCHETE ;
elemento ::= elemento COMA expresion
| expresion
;
```


### Ejecución del programa
Para la ejecución del programa, como se mencionó previamente, se crearon muchas clases que se fueron guardando durante el análisis sintáctico con cup para que, cuando se tenga que iniciar el programa, se pueda adentrar en estas y ejecutar todo tal y como debería.

#### Clases Abstractas
Estas clases fueron el "molde" con el cual se dio forma a la mayoria de las clases.

```java
public abstract class Expresion extends Sentencia {

    TipoExpresion tipoExpresion;

    public Expresion(TipoExpresion tipoExpresion) {
        super(TipoSentencia.EXPRESION);
        this.tipoExpresion = tipoExpresion;
    }

    public abstract TipoRetorno jugar(Ambiente ambiente);
}

public abstract class Instruccion extends Sentencia {

    TipoInstruccion tipoInstruccion;

    public Instruccion(TipoInstruccion tipoInstruccion) {
        super(TipoSentencia.INSTRUCCION);
        this.tipoInstruccion = tipoInstruccion;
    }

    public abstract void jugar(Ambiente ambiente);

}

public abstract class Sentencia {

    TipoSentencia tipoSetencia;

    public Sentencia(TipoSentencia tipoSetencia) {
        this.tipoSetencia = tipoSetencia;
    }
}
```
#### Clases de Tipos

Este tipo de clases se utilizaron principalmente para darle un tipo de orden a las demás clases, es decir, estas clases son del tipo *enum*, esto quiere decir que estas se presentan como una *lista* que permite que se tenga un estilo *indice* para poder organizar de forma indexada cada una de las varibales.


```java
public enum TipoExpresion {
    LOGICO,
    FUNCION,
    PUNTEO,
    LISTA,
    PRIMITIVO,
    COMPARATIVO,

}

public enum TipoInstruccion {
    REGLA,
    PARTIDA,
    MAIN,
    ESTRATEGIA,
    INICIAL,

}

public class TipoRetorno {

    public TipoTipo tipo;
    public Object valor;

    public TipoRetorno(Object valor, TipoTipo tipo) {
        this.tipo = tipo;
        this.valor = valor;

    }

}

public enum TipoSentencia {
        EXPRESION,
        INSTRUCCION
}

public enum TipoTipo {
    BOOLEANO,
    STRING,
    LISTA,
    DECISION,
    ENTERO,
    FLOTANTE,

}
```

#### Clases de tipo Instruccion
Este tipo de clases, como su nombre indica, contienen las instrucciones, es decir, aquellos objetos que contienen qué es lo que debe de realizar el programa, dado a que son muchas y contiene muchas funciones, unicamente se colocará el código de la más imporatnte que es la clase Inicio, la cual es la que representa la partida unitaria.


```java

public class Inicio extends Instruccion {

    //Declaro todo
    ArrayList<String> partidas;
    Expresion seed;
    int rondas;
    boolean decision1;
    boolean decision2;
    int cooperacion = 0;
    int defeccion = 0;
    int traidor = 0;
    int traicionado = 0;
    int p1 = 0;
    int p2 = 0;
    int coop1 = 0;
    int coop2 = 0;

    Estrategia estrategia1;
    Estrategia estrategia2;

    public Inicio(ArrayList<String> partidas, Expresion seed) {
        super(TipoInstruccion.MAIN);
        this.partidas = partidas;
        this.seed = seed;
    }

    @Override
    public void jugar(Ambiente ambiente) {
        for (String nombrPartida : partidas) {
            Partida partida = ambiente.obtenerPartida(nombrPartida);
            if (partida != null) {
                ejecutarPartida(ambiente, partida);
            }
        }
    }
```
#### Clases de tipo Expresión
Dentro de la gramática hay expresion que se tiene que evaluar para poder devolver el valor de algo, es decir, funciones que al usarse devueven un valor primitivo capaz de ser evaluado para retornar la salida.
```java
public class Comparacion extends Expresion {

    Expresion exp1;
    Expresion exp2;
    String operador;

    public Comparacion(Expresion exp1, String operador, Expresion exp2) {
        super(TipoExpresion.COMPARATIVO);
        this.exp1 = exp1;
        this.exp2 = exp2;
        this.operador = operador;
    }
}

    public class Funcion extends Expresion {

    public String funcion;
    public Expresion expresion1;
    public Expresion expresion2;

    public Funcion(String funcion, Expresion exp1, Expresion exp2) {
        super(TipoExpresion.FUNCION);
        this.funcion = funcion;
        this.expresion1 = exp1;
        this.expresion2 = exp2;
    }
    }

public class Lista extends Expresion {

    ArrayList<Expresion> elementos;

    public Lista(ArrayList<Expresion> lista) {
        super(tipos.TipoExpresion.LISTA);
        this.elementos = lista;
    }

    @Override
    public TipoRetorno jugar(Ambiente ambiente) {
        ArrayList<Boolean> valores = new ArrayList<>();
        for (Expresion exp : elementos) {
            TipoRetorno resultado = exp.jugar(ambiente);

            //Voy añadiendo lo booleanos
            if (resultado.tipo == TipoTipo.DECISION) {
                valores.add((Boolean) resultado.valor);
            } else {
                return null;
            }
        }
        return new TipoRetorno(valores, TipoTipo.LISTA);
    }
}

public class OperacionLogica extends Expresion {

    Expresion exp1;
    Expresion exp2;
    String operador;

    public OperacionLogica(Expresion exp1, String operador, Expresion exp2) {
        super(TipoExpresion.LOGICO);
        this.exp1 = exp1;
        this.exp2 = exp2;
        this.operador = operador;
    }

    @Override
    public TipoRetorno jugar(Ambiente ambiente) {

        TipoRetorno v1 = exp1.jugar(ambiente);
        TipoRetorno v2 = exp2.jugar(ambiente);

        if (v1 == null || v2 == null) {
            System.out.println("alguno es nulo al parecer");
            return null;
        }
        boolean b1 = Boolean.parseBoolean(v1.valor.toString());
        boolean b2 = Boolean.parseBoolean(v2.valor.toString());
        System.out.println("el primero es " + b1 + "y el segundo es " + b2);
        return switch (this.operador) {
            case "&&" ->
                new TipoRetorno(b1 && b2, TipoTipo.BOOLEANO);
            case "||" ->
                new TipoRetorno(b1 || b2, TipoTipo.BOOLEANO);
            default ->
                null;
        };
    }
}


public class Primitiva extends Expresion {

    Object valor;
    TipoTipo tipo;

    public Primitiva(Object valor, TipoTipo tipo) {
        super(TipoExpresion.PRIMITIVO);
        this.valor = valor;
        this.tipo = tipo;
    }

    @Override
    public TipoRetorno jugar(Ambiente ambiente) {
        switch (tipo) {
            case ENTERO -> {
                return new TipoRetorno(Integer.parseInt(valor.toString()), tipo);
            }
            case FLOTANTE -> {
                return new TipoRetorno(Double.parseDouble(valor.toString()), tipo);
            }
            case BOOLEANO -> {
                return new TipoRetorno(valor.toString().equals("true"), tipo);
            }
            case DECISION -> {
                return new TipoRetorno(valor.toString().equals("C"), tipo);
            }
            case STRING -> {
                return new TipoRetorno(valor.toString(), tipo);
            }
            default -> {
            }
        }
        return null;
    }
}

public class RandomNumber extends Expresion {

    public RandomNumber() {
        super(TipoExpresion.PRIMITIVO);
    }

    @Override
    public TipoRetorno jugar(Ambiente ambiente) {
        RandomGenerator gen1 = ambiente.getRandomGenerator();
        double numerito = gen1.nextDouble();
        System.out.println("Numero aleatorio: " + numerito);
        return new TipoRetorno(numerito, TipoTipo.FLOTANTE);
    }
}

public class RondaActual extends Expresion {

    public RondaActual() {
        super(TipoExpresion.PRIMITIVO);
    }

    @Override
    public TipoRetorno jugar(Ambiente ambiente) {
        return new TipoRetorno(ambiente.getRondaActual(), TipoTipo.ENTERO);
    }
}

public class TotalRondas extends Expresion {

    public TotalRondas() {
        super(TipoExpresion.PRIMITIVO);
    }

    @Override
    public TipoRetorno jugar(Ambiente ambiente) {
        return new TipoRetorno(ambiente.getTotalRondas(), TipoTipo.ENTERO);
    }

}
```
#### Clase Run
Esta contiena toda la informaicón de un run.
```java

public class Run {

    public ArrayList<Object> partidas;
    public Object seed;

    public Run(ArrayList<Object> partidas, Object seed) {
        this.partidas = partidas;
        this.seed = seed;
    }

}
```
#### Clase Juego
Esta contiene toda la salida que se presentara en la interfaz gráfica
```java
public class juego {

    public static ArrayList<String> salidona = new ArrayList<>();

}
```
#### Clase Ambiente

Es el entorno actual con todos los datos de este mismo presentes en ese momento del juego 

```java

public class Ambiente {

    //Variables donde guardo las cositas
    Partida partidaActual;
    int rondaActual;
    int totalRondas;
    long seed;
    public String nombre;
    public Map<String, Estrategia> estrategias = new TreeMap<>();
    public Map<String, Partida> partidas = new TreeMap<>();
    private RandomGenerator randomGenerator;

    //Contructor del entorno
    public Ambiente(String nombre) {
        this.nombre = nombre;
    }

    //Cosa de la partida actual
    public void setPartidaActual(Partida partida) {
        this.partidaActual = partida;
    }

    //Obtiene la partida actual
    public Partida getPartidaActual() {
        return this.partidaActual;
    }

    //Coloca el número de ronda actual
    public void setRondaActual(int ronda) {
        this.rondaActual = ronda;
    }

    //Obtiene el númoer de ronda Actual
    public int getRondaActual() {
        return this.rondaActual;
    }

    //Coloca el totol de rondas
    public void setTotalRondas(int ronda) {
        this.totalRondas = ronda;
    }

    //Retorna el total de rodas
    public int getTotalRondas() {
        return this.totalRondas;
    }

    //obtiene la seed
    public double getSeed() {
        return this.seed;
    }

    //pone la seed
    public void setSeed(long seed) {
        this.seed = seed;
    }

    //el random xd
    public RandomGenerator getRandomGenerator() {
        return this.randomGenerator;
    }

    //el random xd
    public void setRandomGenerator(RandomGenerator randomGenerator) {
        this.randomGenerator = randomGenerator;
    }

    //Guardo la estrategia que se ejecuta
    public boolean guardarEstrategia(String nombre, Estrategia estrategia) {
        if (!this.estrategias.containsKey(nombre)) {
            // System.out.println("ESTR: " + nombre);
            this.estrategias.put(nombre, estrategia);
            return true;
        }
        return false;
    }

    //Guardo la partida que se ejecuta
    public boolean guardarPartida(String nombre, Partida partida) {
        if (!this.partidas.containsKey(nombre)) {
            this.partidas.put(nombre, partida);
            // System.out.println("Se está guardando la partida");
            return true;
        }
        return false;
    }

    //Se obtiene la partida que se está ejecutando
    public Partida obtenerPartida(String nombre) {
        if (partidas.containsKey(nombre)) {
            // System.out.println("Encuentra la partida");
            return partidas.get(nombre);
        }
        return null;
    }

    //Obtiene la estrategia que se está usando
    public Estrategia obtenerEstrategia(String nombre) {
        if (estrategias.containsKey(nombre)) {
            // System.out.println("Encuentra la estrategia");
            return estrategias.get(nombre);
        }
        return null;
    }

}

```
#### Clase Estrategia
Contiene toda la información de una estrategia
```java
public class Estrategia {

    public String nombre;
    public InstruccionEstrategia instrucciones;
    public ArrayList<Boolean> historial = new ArrayList<>();
    public boolean state;

    public Estrategia(String nombre, InstruccionEstrategia instrucciones) {
        this.nombre = nombre;
        this.instrucciones = instrucciones;
    }

}


```


#### Clase Puntaje
Contine la información de todos los puntajes que se le da al jugador de pendiendo de la desición que este tome
```java



public class Puntaje {
    public Expresion cooperacion;
    public Expresion defeccion;
    public Expresion traidor;
    public Expresion traicionado;
    
    public Puntaje(Expresion cooperacion, Expresion defeccion, Expresion traidor, Expresion traicionado) {
        this.cooperacion = cooperacion;
        this.defeccion = defeccion;
        this.traidor = traidor;
        this.traicionado = traicionado;
    }
    
}


